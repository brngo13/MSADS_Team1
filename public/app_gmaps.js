/**
 * Facility Risk Mapper - Google Maps Implementation
 * Displays EPA facility data from predictions CSV with GEE census tract boundaries
 *
 * NOTE: Common utilities (data loading, filters, colors) are in app_common.js
 * This file contains only Google Maps-specific implementations
 */

// Google Maps-specific global variables
let map;
let markers = [];
let clusterer = null;
let censusTractLayer = null;
let censusBlockGroupLayer = null;
let adiDataLayer = null;
let currentAdiYear = null;

// GEE tile URLs for TIGER/2010 boundaries (generated by Python script)
const GEE_TRACTS_TILE_URL = 'https://earthengine.googleapis.com/v1/projects/msads-mba-autumn-2025-team-1/maps/2f98272aca3249b42f75fa84bc3c35c4-c25230ef7a86c610cae92f15b97682c4/tiles/{z}/{x}/{y}';
const GEE_BLOCK_GROUPS_TILE_URL = 'https://earthengine.googleapis.com/v1/projects/msads-mba-autumn-2025-team-1/maps/f7b00c7c538658f0848172268a8d3272-b6da6ffd19c74fd865211157d4b03b36/tiles/{z}/{x}/{y}';

/**
 * Initialize Google Map (callback from Maps API)
 */
function initMap() {
    // Get config from global (loaded in HTML)
    const config = window.APP_CONFIG || {};
    // Default to Illinois center (where the data is)
    const mapDefaults = config.mapDefaults || { center: { lat: 40.6331, lng: -89.3985 }, zoom: 7 };

    // Create map with config defaults
    map = new google.maps.Map(document.getElementById('map'), {
        center: mapDefaults.center,
        zoom: mapDefaults.zoom,
        mapTypeId: 'roadmap',
        styles: isDarkTheme ? getDarkMapStyle() : getLightMapStyle(),
        mapTypeControl: true,
        mapTypeControlOptions: {
            position: google.maps.ControlPosition.TOP_RIGHT
        },
        fullscreenControl: true,
        fullscreenControlOptions: {
            position: google.maps.ControlPosition.TOP_RIGHT
        },
        streetViewControl: false,
        zoomControl: true,
        zoomControlOptions: {
            position: google.maps.ControlPosition.RIGHT_TOP
        }
    });

    // Initialize UI
    setupEventListeners();
    setTheme(isDarkTheme); // From app_common.js

    // Load facility data (from app_common.js)
    loadFacilityData();

    // Census layers are loaded on demand via radio button selection
    // Default is "none" - no boundaries displayed
}

/**
 * Plot emissions on map (called by app_common.js applyFilters)
 * This wraps the Google Maps-specific createMarkers() function
 */
function plotEmissions() {
    createMarkers();
    updateFacilityCount();
}

/**
 * Create map markers from facility data
 */
function createMarkers() {
    // Clear existing markers and clusterer
    if (clusterer) {
        clusterer.clearMarkers();
    }
    markers.forEach(marker => marker.setMap(null));
    markers = [];

    filteredData.forEach(facility => {
        const lat = parseFloat(facility['site latitude']);
        const lng = parseFloat(facility['site longitude']);
        const riskLevel = facility['risk_level'] || 'Unknown';
        const totalEmissions = parseFloat(facility['total_emissions']) || 0;

        // Determine marker colors based on risk level
        const colors = getRiskColors(riskLevel);

        // Marker size based on total emissions (log scale)
        // Scale: 10-1000 tons = radius 5-15, 1000-100000 tons = radius 15-30
        const logEmissions = Math.log10(Math.max(1, totalEmissions));
        const radius = Math.min(30, Math.max(5, 5 + logEmissions * 5));

        // Create circular icon
        const icon = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: colors.fill,
            fillOpacity: 0.7,
            strokeColor: colors.stroke,
            strokeWeight: 2,
            scale: radius
        };

        const marker = new google.maps.Marker({
            position: { lat, lng },
            icon: icon,
            title: facility['site name'] || facility['company name'] || 'Unknown Facility',
            facilityData: facility // Store data with marker
        });

        // Add click listener
        marker.addListener('click', () => {
            showFacilityDetails(facility);
        });

        markers.push(marker);
    });

    // Add clustering
    try {
        if (typeof markerClusterer !== 'undefined' && markers.length > 0) {
            // Custom renderer for grey cluster markers
            const renderer = {
                render: ({ count, position }) => {
                    // Grey cluster marker
                    const svg = `
                        <svg fill="#808080" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
                            <circle cx="120" cy="120" opacity="0.6" r="70" />
                            <circle cx="120" cy="120" opacity="0.4" r="90" />
                            <circle cx="120" cy="120" opacity="0.2" r="110" />
                        </svg>
                    `;

                    return new google.maps.Marker({
                        position,
                        icon: {
                            url: `data:image/svg+xml;base64,${btoa(svg)}`,
                            scaledSize: new google.maps.Size(45, 45),
                        },
                        label: {
                            text: String(count),
                            color: "white",
                            fontSize: "12px",
                            fontWeight: "bold",
                        },
                        zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,
                    });
                }
            };

            clusterer = new markerClusterer.MarkerClusterer({
                map: map,
                markers: markers,
                algorithm: new markerClusterer.SuperClusterAlgorithm({
                    radius: 100,  // Cluster radius in pixels
                    maxZoom: 12,  // Don't cluster at zoom 12 and above
                }),
                renderer: renderer
            });
            console.log(`âœ“ Clustered ${markers.length} markers`);
        } else {
            // Fallback: add markers to map without clustering
            console.warn('MarkerClusterer library not available, adding markers individually');
            markers.forEach(marker => marker.setMap(map));
        }
    } catch (e) {
        console.error('Clustering error:', e);
        markers.forEach(marker => marker.setMap(map));
    }
}

/**
 * Get colors for risk level (fill and stroke) - Google Maps specific
 * Returns both fill and stroke colors for marker styling
 */
function getRiskColors(riskLevel) {
    const fillColor = getRiskColor(riskLevel); // From app_common.js

    // Generate darker stroke color from fill
    const strokeColors = {
        '#ef4444': '#991b1b',   // Red -> Darker red
        '#f59e0b': '#d97706',   // Amber -> Darker amber/orange
        '#10b981': '#15803d',   // Green -> Darker green
        '#808080': '#404040'    // Gray -> Darker gray
    };

    return {
        fill: fillColor,
        stroke: strokeColors[fillColor] || '#404040'
    };
}

/**
 * Show facility details in modal
 */
function showFacilityDetails(facility) {
    const modal = document.getElementById('facility-modal');
    const content = document.getElementById('facility-details-content');

    const totalEmissions = parseFloat(facility['total_emissions']).toFixed(2);
    const naicsCode = facility['primary naics code'] || 'N/A';
    const naicsDesc = facility['primary naics description'] || '';

    const html = `
        <div style="max-width: 500px;">
            <h4 style="margin-bottom: 16px; color: var(--text-primary); font-size: 16px;">Site Information</h4>

            <div style="margin-bottom: 12px;">
                <strong>Site Name:</strong> ${facility['site name'] || 'N/A'}
            </div>

            <div style="margin-bottom: 12px;">
                <strong>Facility ID:</strong> ${facility['eis facility id'] || 'N/A'}
            </div>

            <div style="margin-bottom: 12px;">
                <strong>Address:</strong> <span style="color: var(--text-secondary);">(not available)</span>
            </div>

            <div style="margin-bottom: 12px;">
                <strong>State:</strong> <span style="color: var(--text-secondary);">(not available)</span>
            </div>

            <div style="margin-bottom: 12px;">
                <strong>Zip:</strong> <span style="color: var(--text-secondary);">(not available)</span>
            </div>

            <div style="margin-bottom: 12px;">
                <strong>Total Emissions:</strong> ${totalEmissions} tons/year
            </div>

            <div style="margin-bottom: 12px;">
                <strong>NAICS:</strong> ${naicsCode} - ${naicsDesc}
            </div>
        </div>
    `;

    content.innerHTML = html;
    modal.style.display = 'flex';
}

/**
 * Add GEE census tract boundaries layer
 */
function addCensusTractLayer() {
    const CENSUS_MIN_ZOOM = 9;

    // Create ImageMapType for GEE tiles
    censusTractLayer = new google.maps.ImageMapType({
        getTileUrl: function(coord, zoom) {
            // Only load tiles at zoom 9 and above for performance
            if (zoom < CENSUS_MIN_ZOOM) {
                return null;
            }
            // GEE tile URL format: {url}/{z}/{x}/{y}
            return GEE_TRACTS_TILE_URL
                .replace('{z}', zoom)
                .replace('{x}', coord.x)
                .replace('{y}', coord.y);
        },
        tileSize: new google.maps.Size(256, 256),
        opacity: 0.6,
        name: 'Census Tracts',
        minZoom: CENSUS_MIN_ZOOM
    });

    // Add layer to map
    map.overlayMapTypes.push(censusTractLayer);

    // Add zoom listener to show/hide message based on zoom level
    map.addListener('zoom_changed', () => {
        const zoom = map.getZoom();
        const checkbox = document.getElementById('show-census-tracts');

        if (zoom < CENSUS_MIN_ZOOM && checkbox && checkbox.checked) {
            showCensusZoomMessage();
        } else {
            // Remove message when boundaries are visible
            hideCensusZoomMessage();
        }
    });

    // Check initial zoom
    if (map.getZoom() < CENSUS_MIN_ZOOM) {
        showCensusZoomMessage();
    }
}

/**
 * Show message about zooming in to see census tracts
 * Message persists until boundaries are visible (zoom >= 9)
 */
function showCensusZoomMessage() {
    // Only create if it doesn't exist
    const messageDiv = document.getElementById('census-zoom-message');
    if (!messageDiv) {
        // Create message element
        const div = document.createElement('div');
        div.id = 'census-zoom-message';
        div.style.cssText = `
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            font-size: 13px;
            border: 1px solid var(--border);
            transition: opacity 0.3s;
            opacity: 1;
        `;
        div.textContent = 'ðŸ” Zoom in to see census tract boundaries';
        document.body.appendChild(div);
    }
}

/**
 * Hide census zoom message when boundaries become visible
 */
function hideCensusZoomMessage() {
    const messageDiv = document.getElementById('census-zoom-message');
    if (messageDiv) {
        messageDiv.style.opacity = '0';
        setTimeout(() => messageDiv.remove(), 300);
    }
}

/**
 * Add GEE census block group boundaries layer
 */
function addCensusBlockGroupLayer() {
    const CENSUS_MIN_ZOOM = 9;

    // Create ImageMapType for GEE tiles
    censusBlockGroupLayer = new google.maps.ImageMapType({
        getTileUrl: function(coord, zoom) {
            // Only load tiles at zoom 9 and above for performance
            if (zoom < CENSUS_MIN_ZOOM) {
                return null;
            }
            // GEE tile URL format: {url}/{z}/{x}/{y}
            return GEE_BLOCK_GROUPS_TILE_URL
                .replace('{z}', zoom)
                .replace('{x}', coord.x)
                .replace('{y}', coord.y);
        },
        tileSize: new google.maps.Size(256, 256),
        opacity: 0.6,
        name: 'Census Block Groups',
        minZoom: CENSUS_MIN_ZOOM
    });

    // Add layer to map
    map.overlayMapTypes.push(censusBlockGroupLayer);

    // Check initial zoom
    if (map.getZoom() < CENSUS_MIN_ZOOM) {
        showCensusZoomMessage();
    }
}

/**
 * Toggle census tract layer visibility
 */
function toggleCensusTractLayer(show) {
    if (!censusTractLayer) return;

    if (show) {
        if (map.overlayMapTypes.getLength() === 0) {
            map.overlayMapTypes.push(censusTractLayer);
        }
        // Check if we need to show the zoom message
        const CENSUS_MIN_ZOOM = 9;
        if (map.getZoom() < CENSUS_MIN_ZOOM) {
            showCensusZoomMessage();
        }
    } else {
        map.overlayMapTypes.clear();
        // Hide message when layer is turned off
        hideCensusZoomMessage();
    }
}

/**
 * Toggle census block group layer visibility
 */
function toggleCensusBlockGroupLayer(show) {
    if (!censusBlockGroupLayer) return;

    if (show) {
        if (map.overlayMapTypes.getLength() === 0) {
            map.overlayMapTypes.push(censusBlockGroupLayer);
        }
        // Check if we need to show the zoom message
        const CENSUS_MIN_ZOOM = 9;
        if (map.getZoom() < CENSUS_MIN_ZOOM) {
            showCensusZoomMessage();
        }
    } else {
        map.overlayMapTypes.clear();
        // Hide message when layer is turned off
        hideCensusZoomMessage();
    }
}

/**
 * Load social data (wrapper function)
 */
async function loadSocialData() {
    const year = document.getElementById('social-year-selector').value;
    const indicator = document.getElementById('social-indicator-selector').value;

    if (!year) {
        showToast('Please select a year', 'error');
        return;
    }

    if (!indicator) {
        showToast('Please select an indicator', 'error');
        return;
    }

    if (indicator === 'adi') {
        const rankType = document.getElementById('adi-rank-type-selector').value;
        await loadAdiLayer(year, rankType);
    }
}

/**
 * Load ADI choropleth layer by census block groups
 */
async function loadAdiLayer(year, rankType = 'national') {
    const rankLabel = rankType === 'national' ? 'National Rank' : 'State Rank';
    showToast(`Loading ADI ${rankLabel} for ${year}...`, 'info');

    try {
        // Load ADI CSV data
        const adiResponse = await fetch(`/api/adi/${year}`);
        if (!adiResponse.ok) {
            throw new Error(`ADI data for ${year} not found`);
        }
        const adiCsvText = await adiResponse.text();

        // Parse ADI CSV
        adiData = {};
        await new Promise((resolve) => {
            Papa.parse(adiCsvText, {
                header: true,
                skipEmptyLines: true,
                complete: (results) => {
                    results.data.forEach(row => {
                        // Support FIPS, geoid10, or GEOID column names
                        const geoid = row.FIPS || row.geoid10 || row.GEOID;
                        const natRank = parseInt(row.ADI_NATRANK);

                        if (geoid && !isNaN(natRank)) {
                            adiData[geoid] = {
                                natRank: natRank,
                                stateRank: parseInt(row.ADI_STATERNK) || 0
                            };
                        }
                    });
                    resolve();
                }
            });
        });

        console.log(`Loaded ${Object.keys(adiData).length} ADI records`);

        // Load block groups GeoJSON
        const blockGroupsResponse = await fetch('/api/boundaries/block_groups');
        if (!blockGroupsResponse.ok) {
            throw new Error('Block groups GeoJSON not found');
        }
        const blockGroupsGeoJson = await blockGroupsResponse.json();

        // Remove existing ADI layer if present
        if (adiDataLayer) {
            adiDataLayer.setMap(null);
        }

        // Create new data layer
        adiDataLayer = new google.maps.Data();
        adiDataLayer.addGeoJson(blockGroupsGeoJson);

        // Style based on ADI data
        adiDataLayer.setStyle((feature) => {
            const geoid = feature.getProperty('GEOID10');
            const adi = adiData[geoid];

            if (!adi) {
                return {
                    fillColor: '#f3f4f6',
                    fillOpacity: 0.7,
                    strokeColor: '#ffffff',
                    strokeWeight: 0.5,
                    strokeOpacity: 0.7
                };
            }

            // Color based on ADI rank
            const rankValue = rankType === 'national' ? adi.natRank : adi.stateRank;
            let fillColor;

            if (rankType === 'national') {
                // National Rank: 1-100 scale (grey to slate gradient)
                if (rankValue <= 20) {
                    fillColor = '#e5e7eb'; // Very low (light grey)
                } else if (rankValue <= 40) {
                    fillColor = '#cbd5e1'; // Low (grey-blue)
                } else if (rankValue <= 60) {
                    fillColor = '#94a3b8'; // Medium (slate)
                } else if (rankValue <= 80) {
                    fillColor = '#64748b'; // Above average (darker slate)
                } else {
                    fillColor = '#475569'; // High deprivation (dark slate)
                }
            } else {
                // State Rank: 1-10 scale (grey to slate gradient)
                if (rankValue <= 2) {
                    fillColor = '#e5e7eb'; // Very low (light grey)
                } else if (rankValue <= 4) {
                    fillColor = '#cbd5e1'; // Low (grey-blue)
                } else if (rankValue <= 6) {
                    fillColor = '#94a3b8'; // Medium (slate)
                } else if (rankValue <= 8) {
                    fillColor = '#64748b'; // Above average (darker slate)
                } else {
                    fillColor = '#475569'; // High deprivation (dark slate)
                }
            }

            return {
                fillColor: fillColor,
                fillOpacity: 0.7,
                strokeColor: '#ffffff',
                strokeWeight: 0.5,
                strokeOpacity: 0.7
            };
        });

        // Add click listener for ADI info
        adiDataLayer.addListener('click', (event) => {
            const geoid = event.feature.getProperty('GEOID10');
            const name = event.feature.getProperty('NAMELSAD10') || 'Unknown';
            const adi = adiData[geoid];

            if (!adi) {
                new google.maps.InfoWindow({
                    content: `<div style="padding: 8px;">
                        <strong>${name}</strong><br>
                        GEOID: ${geoid}<br>
                        No ADI data available
                    </div>`,
                    position: event.latLng
                }).open(map);
                return;
            }

            new google.maps.InfoWindow({
                content: `<div style="padding: 8px;">
                    <strong>${name}</strong><br>
                    GEOID: ${geoid}<br>
                    ADI National Rank: ${adi.natRank}/100<br>
                    ADI State Rank: ${adi.stateRank}/10
                </div>`,
                position: event.latLng
            }).open(map);
        });

        // Always show the ADI layer when loaded
        adiDataLayer.setMap(map);

        // Update status display
        document.getElementById('social-data-status').innerHTML =
            `<p><strong>Loaded:</strong> ADI ${year}</p>
             <p><strong>Features:</strong> ${Object.keys(adiData).length.toLocaleString()} block groups</p>`;

        // Toggle legend to show ADI
        toggleLegend('adi', rankType);

        currentAdiYear = year;
        showToast(`ADI layer loaded for ${year}`, 'success');

    } catch (error) {
        console.error('Error loading ADI layer:', error);
        showToast('Failed to load ADI data. Ensure data files exist.', 'error');
        document.getElementById('social-data-status').innerHTML =
            `<p style="color: var(--error);">Failed to load data</p>`;
    }
}

/**
 * Toggle legend display between facility risk and ADI
 */
function toggleLegend(type, rankType = 'national') {
    const facilityLegend = document.getElementById('facility-legend');
    const adiLegend = document.getElementById('adi-legend');

    if (type === 'adi') {
        // Keep facility legend visible, just show ADI legend as well
        adiLegend.style.display = 'block';

        // Update legend text based on rank type
        const legendItems = adiLegend.querySelectorAll('.legend-text');
        if (rankType === 'national') {
            legendItems[0].textContent = 'Low Disadvantage (1-20)';
            legendItems[1].textContent = 'Below Average (21-40)';
            legendItems[2].textContent = 'Average (41-60)';
            legendItems[3].textContent = 'Above Average (61-80)';
            legendItems[4].textContent = 'High Disadvantage (81-100)';
            document.querySelector('#adi-legend .legend-title').textContent = 'ADI National Rank';
        } else {
            legendItems[0].textContent = 'Low Disadvantage (1-2)';
            legendItems[1].textContent = 'Below Average (3-4)';
            legendItems[2].textContent = 'Average (5-6)';
            legendItems[3].textContent = 'Above Average (7-8)';
            legendItems[4].textContent = 'High Disadvantage (9-10)';
            document.querySelector('#adi-legend .legend-title').textContent = 'ADI State Rank';
        }
    } else {
        // When not showing ADI, hide ADI legend (facility legend stays visible)
        adiLegend.style.display = 'none';
    }
}

/**
 * Handle census boundary type selection
 */
function handleCensusBoundaryChange(boundaryType) {
    // Hide census zoom message
    hideCensusZoomMessage();

    // Clear all boundary layers first
    toggleCensusTractLayer(false);
    toggleCensusBlockGroupLayer(false);

    // Show selected boundary type
    if (boundaryType === 'tract') {
        if (!censusTractLayer) {
            addCensusTractLayer();
        } else {
            toggleCensusTractLayer(true);
        }
    } else if (boundaryType === 'block') {
        if (!censusBlockGroupLayer) {
            addCensusBlockGroupLayer();
        } else {
            toggleCensusBlockGroupLayer(true);
        }
    }
    // If 'none', both layers are already hidden
}

/**
 * Update facility count display
 */
function updateFacilityCount() {
    document.getElementById('facility-count').textContent = filteredData.length;
}

/**
 * Setup Google Maps-specific event listeners
 * Common listeners (filters, theme, modal) are in app_common.js
 */
function setupEventListeners() {
    // Social data controls (Google Maps specific)
    document.getElementById('load-social-data').addEventListener('click', loadSocialData);
}

/**
 * Update map theme (called by app_common.js setTheme)
 * Google Maps-specific theme update
 */
function updateMapTheme(dark) {
    if (map) {
        map.setOptions({
            styles: dark ? getDarkMapStyle() : getLightMapStyle()
        });
    }
}

/**
 * Get light map style (hide POIs and road labels, faint roads)
 */
function getLightMapStyle() {
    return [
        // Hide all POIs (points of interest)
        {
            featureType: "poi",
            stylers: [{ visibility: "off" }]
        },
        {
            featureType: "poi.business",
            stylers: [{ visibility: "off" }]
        },
        {
            featureType: "transit",
            stylers: [{ visibility: "off" }]
        },
        // Hide all road labels
        {
            featureType: "road",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
        },
        // Make roads fainter
        {
            featureType: "road",
            elementType: "geometry",
            stylers: [{ lightness: 50 }]
        },
        {
            featureType: "road.highway",
            elementType: "geometry",
            stylers: [{ lightness: 40 }]
        }
    ];
}

/**
 * Get dark map style (hide POIs and road labels, faint roads)
 */
function getDarkMapStyle() {
    return [
        // Hide all POIs first
        {
            featureType: "poi",
            stylers: [{ visibility: "off" }]
        },
        {
            featureType: "poi.business",
            stylers: [{ visibility: "off" }]
        },
        {
            featureType: "transit",
            stylers: [{ visibility: "off" }]
        },
        // Dark theme colors
        { elementType: "geometry", stylers: [{ color: "#242f3e" }] },
        { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] },
        { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] },
        {
            featureType: "administrative.locality",
            elementType: "labels.text.fill",
            stylers: [{ color: "#d59563" }],
        },
        // Hide all road labels
        {
            featureType: "road",
            elementType: "labels",
            stylers: [{ visibility: "off" }]
        },
        // Make roads fainter (lighter/more subtle colors)
        {
            featureType: "road",
            elementType: "geometry",
            stylers: [{ color: "#2d3748" }],
        },
        {
            featureType: "road",
            elementType: "geometry.stroke",
            stylers: [{ color: "#1f2835" }],
        },
        {
            featureType: "road.highway",
            elementType: "geometry",
            stylers: [{ color: "#4a5568" }],
        },
        {
            featureType: "road.highway",
            elementType: "geometry.stroke",
            stylers: [{ color: "#2d3748" }],
        },
        {
            featureType: "transit",
            elementType: "geometry",
            stylers: [{ color: "#2f3948" }],
        },
        {
            featureType: "transit.station",
            elementType: "labels.text.fill",
            stylers: [{ color: "#d59563" }],
        },
        {
            featureType: "water",
            elementType: "geometry",
            stylers: [{ color: "#17263c" }],
        },
        {
            featureType: "water",
            elementType: "labels.text.fill",
            stylers: [{ color: "#515c6d" }],
        },
        {
            featureType: "water",
            elementType: "labels.text.stroke",
            stylers: [{ color: "#17263c" }],
        },
    ];
}

console.log('âœ“ app_gmaps.js loaded - Google Maps implementation ready');
